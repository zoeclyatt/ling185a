Zoe Clyatt
UID: 505020340
LING 185A
2021.12.10

-------------------
-- FINAL PROJECT --
-------------------

   For my final project, I chose to work on transition-based CFG parsing.
I did this because I just think CFGs are really neat and learning about the
different parsing schemas for them was my favorite part of the material we
covered in this class. I've learned about CFGs in other classes before, but
I've only seen very simple examples that are not linguistically interesting
in computer science classes. While the CFG rules that I used for my test
data were relatively simple compared to syntax rules of human languages, it
was fun to work with a set of rules that allow for the generation of more
complex sentences. Coding the functions that would allow me to use a computer
to parse these sentences felt like it would be useful and interesting, and 
while I may not have gotten around to writing a search function since I ran 
out of time, I can see how that would be a useful tool. Since I was already
fairly comfortable with CFGs and the parsing schemas, I feel like most of
what I learned was how to translate these concepts into code, and I became
a lot more proficient in using Haskell as well. For the homework assignments, 
the types declarations (not sure if that's what they're called) of all the 
functions we had to write were given to us, so I never really learned how 
they worked, but after having to come up with my own functions with different
input and return types, I feel more comfortable being able to write code in
Haskell without such detailed instructions like on the homeworks.

   I used code from the final project instructions for the StackSymbol and 
Configuration types, and I used the data types Cat and Rule from ContextFree.hs.
For my test data I used the sentences and rules for the CFG in the class 
handout for week 7. For the sentences, I converted the strings for the 
sentences using Haskell's built-in words function, and one thing I realized 
while translating the CFG rules into code was that in order to fully encompass
all of the possible combinations of nonterminals on the right hand side of a 
rule, multiple rules with each possible combination of right hand side elements
were needed, which made this task a bit more complicated than expected.


DESCRIPTIONS OF FUNCTIONS AND TEST CASES
- shift: uses the head of the configuration's nonterminals and checks if it 
   can be shifted over to the nonterminal side using shiftHelper
   
   test case:
   *Final> shift rules ([], lba)
           [([NP],["won"])]

- shiftHelper: takes a list of rules and a terminal element, returning the
   corresponding nonterminal left hand side symbol for the rule that matches

   test case:
   *Final> shiftHelper rules "Mary"
           [NP]

- reduce: goes through the rules and if it finds a match, then it replaces the
   nonterminal side of a configuration with the reduced list of nonterminals
   generated by reduceHelper

   test case:
   *Final> reduce rules ([NP, V], [""])
           [([NP,VP],[""]),([ORC],[""]),([NP,V],[""])]

- reduceHelper: simultaneously recurses backwards through the right hand 
   side of a rule and a list of nonterminals, if it reaches the end of the
   right hand side, it replaces all of those symbols with the left hand side
   of the rule

   test case:
   *Final> reduceHelper NP [D, N] [D, N]
           [NP]

- predict: makes a list of all of the predicted configurations based on a set
   of rules and an initial configuration

   test case:
   *Final> predict rules ([S], [""])
           [([NP,VP],[""]),([WHILE,S,S],[""]),([S],[""])]

- predictHelper: if the left hand side of a rule matches the head of the given
   list of nonterminals, it appends the tail of that list of nonterminals to the
   right hand side of that rule

   test case:
   *Final> predictHelper S [NP, VP] [S]
           [NP,VP]

- match: matches the head of the nonterminals of a configuration with the lhs of a rule
   and returns the reduced nonterminals and terminals if the head of the terminals
   is the right hand side of the rule

   test case:
   *Final> match rules ([NP, VP], lba)
           [([VP],["won"])]

- lcPredict: same thing as predict but using Configuration (StackSymbol nt) t

   test case:
   *Final> lcPredict rules ([Plain NP, Barred S], [""])
           [([Barred VP,Plain S,Barred S],[""]),([Barred POSS,Barred N,Plain NP,Barred S],[""]),([Barred V,Plain ORC,Barred S],[""]),([Plain NP,Barred S],[""])]

- lcPredictHelper: same thing as predictHelper but using configuration type above

   test case:
   *Final> lcPredictHelper S [NP, VP] [Plain NP]
           [Barred VP,Plain S]

- bar: takes a list of nts and makes them Barred nts

   test case:
   *Final> bar [D, N, NP, S]
           [Barred D,Barred N,Barred NP,Barred S]

- lcConnect: makes list of configurations based on all possible combinations to 
   connect a rule using lcConnectHelper

   test case: 
   *Final> lcConnect rules ([Plain NP, Barred S], [""])
           [([Barred VP],[""]),([Plain NP,Barred S],[""])]

- lcConnectHelper: if the first element of the nonterminals is a Plain nt and the
   second element is a Barred nt and they match the lhs and rhs of a rule respectively,
   then replace the first two elements with barred bersions of the right hand side

   test case:
   *Final> lcConnectHelper S [NP, VP] [Plain NP, Barred S]
           [Barred VP]

- lcShift: same thing as shift but using Coonfiguration (StackSymbol nt) t

   test case:
   *Final> lcShift rules ([Barred S], lba)
           [([Plain NP,Barred S],["won"])]

- lcShiftHelper: same thing as shiftHelper but using configuration type above

   test case:
   *Final> lcShiftHelper rules "Mary"
           [Plain NP]

- lcMatch: same thing as match but using configuration type above

   test case:
   *Final> lcMatch rules ([Barred N, Plain NP, Barred S], (words "baby saw the boy"))
           [([Plain NP,Barred S],["saw","the","boy"])]
